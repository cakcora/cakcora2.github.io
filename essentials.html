<html>
<head></head>
<body>
<h2>Essential readings on computer science</h2>
<p><a href = "https://en.wikipedia.org/wiki/The_Mythical_Man-Month">The mythical man month</a> from Fred Brooks is the most essential reading in software engineering (Don't quote me on that). Concepts from this book will keep reappearing in the 'essential articles' that I list below. After reading it, you can consider reading <a href="https://en.wikipedia.org/wiki/Coders_at_work">Coders at work</a> for recent practices on software engineering.</p>
<p>I have 37 such required readings that I will be adding to the list below.</p>
<table>
  <tr>
    <td><a href="http://www.paulgraham.com/icad.html" target="_blank">Revenge of the nerds (in html)</a> <a href="https://www.eecis.udel.edu/~decker/courses/280f07/paper/Revenge.pdf">(in a nice PDF)</a></td>
    <td>Paul Graham</td>
    <td>Usually quoted in its last paragraph (that advises against software patterns), this article is actually about why and how programming languages are different from each other, and why you should not stick to the industry standard in choosing the language.</td>
    <td>QUOTE: The disadvantage of believing that all programming languages are equivalent is that it's not true. But the advantage is that it makes your life a lot simpler. And I think that's the main reason the idea is so widespread. It is a comfortable idea.</td>
    <td>9p</td>
    <td>2002</td>
  </tr>
   <tr>
    <td><a href="http://www.martinfowler.com/ieeeSoftware/protectedVariation.pdf" target="_blank">Protected Variation: The Importance of Being Closed.</a></td>
    <td>Craig Larman</td>
    <td>Explains the Protected Variation principle, which covers the Information Hiding and Open-Closed principles.</td>
    <td>QUOTE: For example, I recall being surprised by the occasional use of static public final fields in the Java technology libraries (after spending many years with the Smalltalk libraries). Some might be poorly conceived, but some, such as the Color static fields red, black, white, and so forth, are extremely stable; the likelihood of instability is so low that making them private and adding accessing methods is just object purism.</td>
    <td>3p</td>
    <td>2001</td>
  </tr>
  <tr>
    <td><a href="https://www.cs.umd.edu/class/spring2003/cmsc838p/Design/criteria.pdf" target="_blank">On the Criteria To Be Used in Decomposing Systems into Modules.</a></td>
    <td>D.L. Parnas</td>
    <td>Gives a step by step decision process on what to consider in modularization.</td>
    <td>QUOTE: It is almost always incorrect to begin the decomposition of a system into modules on the basis of a flowchart. We propose instead that one begins with a list of difficult design decisions or design decisions which are likely to change. Each module is then designed to hide such a decision from the others.</td>
    <td>6p</td>
    <td>1972</td>
  </tr>
  <tr>
    <td><a href="http://people.inf.ethz.ch/wirth/Miscellaneous/IEEE-Annals.pdf" target="_blank">A Brief History of Software Engineering.</a></td>
    <td>Niklaus Wirth</td>
    <td>A must read article to see how the dots were connected in “computer science” (or “informatics” as they call it in Europe).</td>
    <td>QUOTE: 1.	One might have classified C as being somewhere between misleading and even dangerous. But on the contrary, people at large, particularly in academia, found it intriguing and “better than assembly code”, because it featured some syntax.
2.	The Alto caused nothing less than a revolution, and as a result people to-day have no idea, how computing was done before 1975 without personal, highly interactive workstations.
3.	Modern languages like Java and C# may well be superior to old ones like Fortran, PL/I, and C, but they are far from perfect, and they could be much better. Their manuals of several hundred pages are an unmistakable symptom of their inadequacy.</td>
    <td>10p</td>
    <td>2008</td>
  </tr>
  <tr>
    <td><a href="https://www.ece.cmu.edu/~ganger/712.fall02/papers/p761-thompson.pdf" target="_blank">Reflections on trusting trust.</a></td>
    <td>Ken Thompson</td>
    <td>This is a Turing Award Lecture that I found somehow bland. But at least it poked my interest enough to make me write a Quine class for the first time.</td>
    <td>QUOTE: The act of breaking into a computer system has to have the same social stigma as breaking into a neighbor's house. It should not matter that the neighbor's door is unlocked.</td>
    <td>3p</td>
    <td>1984</td>
  </tr>
  <tr>
    <td><a href="https://en.wikipedia.org/wiki/No_Silver_Bullet" target="_blank">No silver bullet – Essence and accident in software engineering.</a></td>
    <td>Fred Brooks</td>
    <td>Turing award winner Brooks mentions all fundamental improvements software engineering had so far, and one by one explains why none of them is the magical panacea we seek. I especially liked his suggestions on how to nurture young talent and why it is important.</td>
    <td>QUOTE: 1.	There is no single development, in either technology or management technique, which by itself promises even one order of magnitude [tenfold] improvement within a decade in productivity, in reliability, in simplicity.
2.	Software people are not alone in facing complexity. Physics deal with terribly complex objects even at the fundamental particle level. The physicist labors on, however, in a firm faith that there are unifying principles to be found, whether in quarks or in unified field theories. Einstein repeatedly argued that there must be simplified explanations of nature, because God is not capricious or arbitrary. No such faith comforts the software engineer.
</td>
    <td>16p</td>
    <td>1986</td>
  </tr>
  <tr>
    <td><a href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD02xx/EWD215.html" target="_blank">Case against the GO TO Statement.</a></td>
    <td>Edsger Djisktra</td>
    <td>Shows how a master can kill a (bad) practice (i.e., using go to statements) single handedly. For those looking for a short summary, Djisktra is convinced that “goto statements make it very hard to find a meaningful set of coordinates in which to describe the process progress”. In my words, this means that you cannot know which line the program was executing before or where it will return after. </td>
    <td>QUOTE: Since a number of years I am familiar with the observation that the quality of programmers is a decreasing function of the density of the go to statements in the programs they produce.</td>
    <td>5p</td>
    <td>1968</td>
  </tr>
  <tr>
    <td><a href="" target="_blank">.</a></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td><a href="" target="_blank">.</a></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  </table>
 
</body>
</html>
